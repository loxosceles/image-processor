#/bin/bash
if [ -f .env ]; then
    export $(grep -v '^#' .env | xargs)
fi

### Main functions
##
#
run() {
    local input_folder="$1"
    local output_folder="$2"
    local task="$3"
    docker compose run --rm image_processor "$input_folder" "$output_folder" --task "$task"
}

build_and_push() {
    echo $GITHUB_PAT | docker login ghcr.io -u $GITHUB_USERNAME --password-stdin &&
        cd image_processor &&
        docker build -t image_processor . &&
        docker tag image_processor ghcr.io/$GITHUB_USERNAME/image_processor:$TAG &&
        docker push ghcr.io/$GITHUB_USERNAME/image_processor:$TAG
}

### Helper functions
##
#
_check_mutually_exclusive_args() {
    local run_count=0
    local build_count=0

    for arg in "$@"; do
        case "$arg" in
        run)
            run_count=$((run_count + 1))
            ;;
        build)
            build_count=$((build_count + 1))
            ;;
        esac
    done

    if [ "$run_count" -gt 0 ] && [ "$build_count" -gt 0 ]; then
        echo "Error: 'run' and 'build' cannot be used together."
        exit 1
    fi
}

# ARG_OPTIONAL_SINGLE([input],[i],[Input folder])
# ARG_OPTIONAL_SINGLE([output],[o],[Output folder])
# ARG_OPTIONAL_SINGLE([task],[t],[Task to perform])
# ARG_HELP([<input_folder> <output_folder> <task>])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die() {
    local _ret="${2:-1}"
    test "${_PRINT_HELP:-no}" = yes && print_help >&2
    echo "$1" >&2
    exit "${_ret}"
}

begins_with_short_option() {
    local first_option all_short_options='ioth'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_input=
_arg_output=
_arg_task=

print_help() {
    printf '%s\n' "<input_folder> <output_folder> <task>"
    printf 'Usage: %s [-i|--input <arg>] [-o|--output <arg>] [-t|--task <arg>] [-h|--help]\n' "$0"
    printf '\t%s\n' "-i, --input: Input folder (no default)"
    printf '\t%s\n' "-o, --output: Output folder (no default)"
    printf '\t%s\n' "-t, --task: Task to perform (no default)"
    printf '\t%s\n' "-h, --help: Prints help"
}

parse_commandline() {
    while test $# -gt 0; do
        _key="$1"
        case "$_key" in
        -i | --input)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_input="$2"
            shift
            ;;
        --input=*)
            _arg_input="${_key##--input=}"
            ;;
        -i*)
            _arg_input="${_key##-i}"
            ;;
        -o | --output)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_output="$2"
            shift
            ;;
        --output=*)
            _arg_output="${_key##--output=}"
            ;;
        -o*)
            _arg_output="${_key##-o}"
            ;;
        -t | --task)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_task="$2"
            shift
            ;;
        --task=*)
            _arg_task="${_key##--task=}"
            ;;
        -t*)
            _arg_task="${_key##-t}"
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        -h*)
            print_help
            exit 0
            ;;
        --build-and-push)
            build_and_push
            exit 0
            ;;
        *)
            _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
            ;;
        esac
        shift
    done
}

_check_mutually_exclusive_args "$@"

if [ "$1" = "run" ]; then
    shift
    parse_commandline "$@"
    if [ -z "$_arg_input" ] || [ -z "$_arg_output" ] || [ -z "$_arg_task" ]; then
        print_help
        exit 1
    fi
    run "$_arg_input" "$_arg_output" "$_arg_task"
elif [ "$1" = "build" ]; then
    if [ "$#" -ne 1 ]; then
        echo "Error: 'build' does not take any additional arguments."
        exit 1
    fi
    build_and_push
else
    print_help
    exit 1
fi
